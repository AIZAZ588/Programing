Scope Resulution Operater (::)
            int c =45;
            int main()
            {
                int c =6;
                cout<<"Value of local  c is :"<<    c   <<endl; --> 6
                cout<<"Value of Global c is :"<<    ::c <<endl; --> 45
            }

Type casting
            converting one data type into another
            e.g
            double b = 34.5;
            int c = (int) d;
            or
            int c = int (d);

            or 34.5f --> float ,34.5l --> long double

Reference Variables
            Those Variables which refere to other Variable
            e.g

            float c = 34.5;
            float &y = c; 
            
            cout<<y --> 34.5

Manipulators 
            #include<iomanip>
            cout<< "value of c is "<<setw(4)<<c<<endl; --> assiging 4 characters space

inline functions 
            request to a compiler
            use only for few lines of code.
            it helps us to fasten our execution if one function is called many times
            
            Sentex:
                inline int product (int,int);
            
            Cones:
                Not racommended for larger functions because it will fillup cash memory very fasten
                dont use it for recersive functions
                dont use inline with static Variables


static 
            static Variable are initialized once but will hold his value till program termination

            Sentex:
                static int num = 0;

function overloading
            If multiple functions having same name but parameters of the functions should be different
            is known as Function Overloading.

            e.g 
                int volume (int a)
                int volume (double a)
                int volume (int a, int b)

Classes 
            memory are allocated only when objects are created.
            C++ compiler only allocate new memory blocks for that object parts which are different from other,
            for same properties they allocate same or common mem block

            static Data Members in Class: 
                Also known as class Variables
                Class property.
            
            syntex:
                class Employee{
                    static int count; // dont initialize it , as by defult it is initialized with zero
                }; 

                int Employee :: count = 1000; // init here, if required 

            Static Member Function:
                Functions which only access static data members of class

                syntex:

                static getData(void){
                    cout << "count is  : "<<count<<end;
                }

                Employee :: getData(); -> for result

            Array of objects:
                if we need 1000 objects for Employee class , instead of making one , one making array is more fesible option

                Sentex :
                   Employee person[1000];
                   for (int i =0; i < 10000; i++)
                   {
                        person[i].functions();
                   }
            protected members:
                They can be inherited.
                They can't be accessed directly(like private members).


Inheritance:
            * Provide Reusability.
            * Existing is called Base Class.
            * New class is Derived Class.

            Forms:
                * Single Inheritance            : A -> B
                * Multiple Inheritance          : A,B -> C
                * Hierarachical Inheritance     : A -> B , C
                * Multilevel Inheritance        : A -> B -> C
                * Hybrid Inheritance            : A -> (A,B) -> D

Constuctors in Derived Class: Constuctors are initaized accourding to the order of respactive classes declatation
            Constuctors of virutal class will be called first.

           Constuctors of Multiple class will be called accourding to their level
            e.g
                To call constructors in this order
                A -> B -> C
                class C : public A, public B
            
Initialization list in constructor: if constructor takes an arguments then it will be initaized accourding to order of arguments.
            e.g 
                Class test{
                    private:
                        int a;
                        int b;
                    public:
                        test(int value1 , int value2 ): a(value1), b(value2)
                        {
                            //code
                        } 

                    //    test(int value1 , int value2 ): b(value1), A(value2)
                    //    {
                    //        //code// This will give error  as order is not same
                    //    } 
                        
                };


Note: pointer of base class can point to derived class, but we can only access base class elements
    e.g 
        BaseClass *Bptr;

        DerivedClass Dobj;
        Bptr = &Dobj;

        Now:
        Bptr -> only access BaseClass elements, and will through error when accessing DerivedClass elements

    Note: when function overloading occures in above case, then by adding 'virtual' keyWord to BaseClass function
          compiler will call derived class function. 

          Rules for virtual functions
          1. They can not br static
          2. They are accessed by object pointers
          3. Virtual function can be a friend of another class
          4. A virtual function of base class might not be used.

Abstract Base Class:
    That class which are only ment for Derived Class,we can not use to make objects of that class, but only use by other classes to derive itself.
    it has at lest one pure virtual functions(or do-nothing functions)
        e.g 
            virtual void display()=0;
    This display function will required to define in derived class, otherwise it will through error

Polymorphism : 
